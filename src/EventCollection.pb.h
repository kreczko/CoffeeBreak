// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: EventCollection.proto

#ifndef PROTOBUF_EventCollection_2eproto__INCLUDED
#define PROTOBUF_EventCollection_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace HEP {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_EventCollection_2eproto();
void protobuf_AssignDesc_EventCollection_2eproto();
void protobuf_ShutdownFile_EventCollection_2eproto();

class FourVector;
class Particle;
class Jet;
class Electron;
class Muon;
class MET;
class Vertex;
class Event;
class EventCollection;

enum Jet_JetAlgorithm {
  Jet_JetAlgorithm_Calo_AntiKT_Cone05 = 0,
  Jet_JetAlgorithm_CA08PF = 1,
  Jet_JetAlgorithm_PF2PAT = 2
};
bool Jet_JetAlgorithm_IsValid(int value);
const Jet_JetAlgorithm Jet_JetAlgorithm_JetAlgorithm_MIN = Jet_JetAlgorithm_Calo_AntiKT_Cone05;
const Jet_JetAlgorithm Jet_JetAlgorithm_JetAlgorithm_MAX = Jet_JetAlgorithm_PF2PAT;
const int Jet_JetAlgorithm_JetAlgorithm_ARRAYSIZE = Jet_JetAlgorithm_JetAlgorithm_MAX + 1;

const ::google::protobuf::EnumDescriptor* Jet_JetAlgorithm_descriptor();
inline const ::std::string& Jet_JetAlgorithm_Name(Jet_JetAlgorithm value) {
  return ::google::protobuf::internal::NameOfEnum(
    Jet_JetAlgorithm_descriptor(), value);
}
inline bool Jet_JetAlgorithm_Parse(
    const ::std::string& name, Jet_JetAlgorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Jet_JetAlgorithm>(
    Jet_JetAlgorithm_descriptor(), name, value);
}
enum Electron_ElectronAlgorithm {
  Electron_ElectronAlgorithm_Calo = 0,
  Electron_ElectronAlgorithm_ParticleFlow = 1
};
bool Electron_ElectronAlgorithm_IsValid(int value);
const Electron_ElectronAlgorithm Electron_ElectronAlgorithm_ElectronAlgorithm_MIN = Electron_ElectronAlgorithm_Calo;
const Electron_ElectronAlgorithm Electron_ElectronAlgorithm_ElectronAlgorithm_MAX = Electron_ElectronAlgorithm_ParticleFlow;
const int Electron_ElectronAlgorithm_ElectronAlgorithm_ARRAYSIZE = Electron_ElectronAlgorithm_ElectronAlgorithm_MAX + 1;

const ::google::protobuf::EnumDescriptor* Electron_ElectronAlgorithm_descriptor();
inline const ::std::string& Electron_ElectronAlgorithm_Name(Electron_ElectronAlgorithm value) {
  return ::google::protobuf::internal::NameOfEnum(
    Electron_ElectronAlgorithm_descriptor(), value);
}
inline bool Electron_ElectronAlgorithm_Parse(
    const ::std::string& name, Electron_ElectronAlgorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Electron_ElectronAlgorithm>(
    Electron_ElectronAlgorithm_descriptor(), name, value);
}
// ===================================================================

class FourVector : public ::google::protobuf::Message {
 public:
  FourVector();
  virtual ~FourVector();
  
  FourVector(const FourVector& from);
  
  inline FourVector& operator=(const FourVector& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FourVector& default_instance();
  
  void Swap(FourVector* other);
  
  // implements Message ----------------------------------------------
  
  FourVector* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FourVector& from);
  void MergeFrom(const FourVector& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double energy = 1;
  inline bool has_energy() const;
  inline void clear_energy();
  static const int kEnergyFieldNumber = 1;
  inline double energy() const;
  inline void set_energy(double value);
  
  // required double px = 2;
  inline bool has_px() const;
  inline void clear_px();
  static const int kPxFieldNumber = 2;
  inline double px() const;
  inline void set_px(double value);
  
  // required double py = 3;
  inline bool has_py() const;
  inline void clear_py();
  static const int kPyFieldNumber = 3;
  inline double py() const;
  inline void set_py(double value);
  
  // required double pz = 4;
  inline bool has_pz() const;
  inline void clear_pz();
  static const int kPzFieldNumber = 4;
  inline double pz() const;
  inline void set_pz(double value);
  
  // @@protoc_insertion_point(class_scope:HEP.FourVector)
 private:
  inline void set_has_energy();
  inline void clear_has_energy();
  inline void set_has_px();
  inline void clear_has_px();
  inline void set_has_py();
  inline void clear_has_py();
  inline void set_has_pz();
  inline void clear_has_pz();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double energy_;
  double px_;
  double py_;
  double pz_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_EventCollection_2eproto();
  friend void protobuf_AssignDesc_EventCollection_2eproto();
  friend void protobuf_ShutdownFile_EventCollection_2eproto();
  
  void InitAsDefaultInstance();
  static FourVector* default_instance_;
};
// -------------------------------------------------------------------

class Particle : public ::google::protobuf::Message {
 public:
  Particle();
  virtual ~Particle();
  
  Particle(const Particle& from);
  
  inline Particle& operator=(const Particle& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Particle& default_instance();
  
  void Swap(Particle* other);
  
  // implements Message ----------------------------------------------
  
  Particle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Particle& from);
  void MergeFrom(const Particle& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .HEP.FourVector fourVector = 1;
  inline bool has_fourvector() const;
  inline void clear_fourvector();
  static const int kFourVectorFieldNumber = 1;
  inline const ::HEP::FourVector& fourvector() const;
  inline ::HEP::FourVector* mutable_fourvector();
  inline ::HEP::FourVector* release_fourvector();
  
  // required double charge = 2;
  inline bool has_charge() const;
  inline void clear_charge();
  static const int kChargeFieldNumber = 2;
  inline double charge() const;
  inline void set_charge(double value);
  
  // required double mass = 3;
  inline bool has_mass() const;
  inline void clear_mass();
  static const int kMassFieldNumber = 3;
  inline double mass() const;
  inline void set_mass(double value);
  
  // @@protoc_insertion_point(class_scope:HEP.Particle)
 private:
  inline void set_has_fourvector();
  inline void clear_has_fourvector();
  inline void set_has_charge();
  inline void clear_has_charge();
  inline void set_has_mass();
  inline void clear_has_mass();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::HEP::FourVector* fourvector_;
  double charge_;
  double mass_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_EventCollection_2eproto();
  friend void protobuf_AssignDesc_EventCollection_2eproto();
  friend void protobuf_ShutdownFile_EventCollection_2eproto();
  
  void InitAsDefaultInstance();
  static Particle* default_instance_;
};
// -------------------------------------------------------------------

class Jet : public ::google::protobuf::Message {
 public:
  Jet();
  virtual ~Jet();
  
  Jet(const Jet& from);
  
  inline Jet& operator=(const Jet& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Jet& default_instance();
  
  void Swap(Jet* other);
  
  // implements Message ----------------------------------------------
  
  Jet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Jet& from);
  void MergeFrom(const Jet& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Jet_JetAlgorithm JetAlgorithm;
  static const JetAlgorithm Calo_AntiKT_Cone05 = Jet_JetAlgorithm_Calo_AntiKT_Cone05;
  static const JetAlgorithm CA08PF = Jet_JetAlgorithm_CA08PF;
  static const JetAlgorithm PF2PAT = Jet_JetAlgorithm_PF2PAT;
  static inline bool JetAlgorithm_IsValid(int value) {
    return Jet_JetAlgorithm_IsValid(value);
  }
  static const JetAlgorithm JetAlgorithm_MIN =
    Jet_JetAlgorithm_JetAlgorithm_MIN;
  static const JetAlgorithm JetAlgorithm_MAX =
    Jet_JetAlgorithm_JetAlgorithm_MAX;
  static const int JetAlgorithm_ARRAYSIZE =
    Jet_JetAlgorithm_JetAlgorithm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  JetAlgorithm_descriptor() {
    return Jet_JetAlgorithm_descriptor();
  }
  static inline const ::std::string& JetAlgorithm_Name(JetAlgorithm value) {
    return Jet_JetAlgorithm_Name(value);
  }
  static inline bool JetAlgorithm_Parse(const ::std::string& name,
      JetAlgorithm* value) {
    return Jet_JetAlgorithm_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .HEP.Particle basic = 1;
  inline bool has_basic() const;
  inline void clear_basic();
  static const int kBasicFieldNumber = 1;
  inline const ::HEP::Particle& basic() const;
  inline ::HEP::Particle* mutable_basic();
  inline ::HEP::Particle* release_basic();
  
  // optional .HEP.Jet.JetAlgorithm type = 2 [default = PF2PAT];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::HEP::Jet_JetAlgorithm type() const;
  inline void set_type(::HEP::Jet_JetAlgorithm value);
  
  // optional double electromagneticFraction = 3 [default = 0];
  inline bool has_electromagneticfraction() const;
  inline void clear_electromagneticfraction();
  static const int kElectromagneticFractionFieldNumber = 3;
  inline double electromagneticfraction() const;
  inline void set_electromagneticfraction(double value);
  
  // optional double numberOfRecHitsContaining90PercentOfTheJetEnergy = 4 [default = 0];
  inline bool has_numberofrechitscontaining90percentofthejetenergy() const;
  inline void clear_numberofrechitscontaining90percentofthejetenergy();
  static const int kNumberOfRecHitsContaining90PercentOfTheJetEnergyFieldNumber = 4;
  inline double numberofrechitscontaining90percentofthejetenergy() const;
  inline void set_numberofrechitscontaining90percentofthejetenergy(double value);
  
  // optional double fractionOfEnergyIntheHottestHPDReadout = 5 [default = 0];
  inline bool has_fractionofenergyinthehottesthpdreadout() const;
  inline void clear_fractionofenergyinthehottesthpdreadout();
  static const int kFractionOfEnergyIntheHottestHPDReadoutFieldNumber = 5;
  inline double fractionofenergyinthehottesthpdreadout() const;
  inline void set_fractionofenergyinthehottesthpdreadout(double value);
  
  // optional uint32 numberOfDaughters = 6 [default = 0];
  inline bool has_numberofdaughters() const;
  inline void clear_numberofdaughters();
  static const int kNumberOfDaughtersFieldNumber = 6;
  inline ::google::protobuf::uint32 numberofdaughters() const;
  inline void set_numberofdaughters(::google::protobuf::uint32 value);
  
  // optional double chargedEmEnergyFraction = 7 [default = 1];
  inline bool has_chargedemenergyfraction() const;
  inline void clear_chargedemenergyfraction();
  static const int kChargedEmEnergyFractionFieldNumber = 7;
  inline double chargedemenergyfraction() const;
  inline void set_chargedemenergyfraction(double value);
  
  // optional double neutralHadronEnergyFraction = 8 [default = 1];
  inline bool has_neutralhadronenergyfraction() const;
  inline void clear_neutralhadronenergyfraction();
  static const int kNeutralHadronEnergyFractionFieldNumber = 8;
  inline double neutralhadronenergyfraction() const;
  inline void set_neutralhadronenergyfraction(double value);
  
  // optional double neutralEmEnergyFraction = 9 [default = 1];
  inline bool has_neutralemenergyfraction() const;
  inline void clear_neutralemenergyfraction();
  static const int kNeutralEmEnergyFractionFieldNumber = 9;
  inline double neutralemenergyfraction() const;
  inline void set_neutralemenergyfraction(double value);
  
  // optional double chargedHadronEnergyFraction = 10 [default = 1];
  inline bool has_chargedhadronenergyfraction() const;
  inline void clear_chargedhadronenergyfraction();
  static const int kChargedHadronEnergyFractionFieldNumber = 10;
  inline double chargedhadronenergyfraction() const;
  inline void set_chargedhadronenergyfraction(double value);
  
  // optional uint32 chargedMultiplicity = 11 [default = 0];
  inline bool has_chargedmultiplicity() const;
  inline void clear_chargedmultiplicity();
  static const int kChargedMultiplicityFieldNumber = 11;
  inline ::google::protobuf::uint32 chargedmultiplicity() const;
  inline void set_chargedmultiplicity(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:HEP.Jet)
 private:
  inline void set_has_basic();
  inline void clear_has_basic();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_electromagneticfraction();
  inline void clear_has_electromagneticfraction();
  inline void set_has_numberofrechitscontaining90percentofthejetenergy();
  inline void clear_has_numberofrechitscontaining90percentofthejetenergy();
  inline void set_has_fractionofenergyinthehottesthpdreadout();
  inline void clear_has_fractionofenergyinthehottesthpdreadout();
  inline void set_has_numberofdaughters();
  inline void clear_has_numberofdaughters();
  inline void set_has_chargedemenergyfraction();
  inline void clear_has_chargedemenergyfraction();
  inline void set_has_neutralhadronenergyfraction();
  inline void clear_has_neutralhadronenergyfraction();
  inline void set_has_neutralemenergyfraction();
  inline void clear_has_neutralemenergyfraction();
  inline void set_has_chargedhadronenergyfraction();
  inline void clear_has_chargedhadronenergyfraction();
  inline void set_has_chargedmultiplicity();
  inline void clear_has_chargedmultiplicity();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::HEP::Particle* basic_;
  double electromagneticfraction_;
  double numberofrechitscontaining90percentofthejetenergy_;
  int type_;
  ::google::protobuf::uint32 numberofdaughters_;
  double fractionofenergyinthehottesthpdreadout_;
  double chargedemenergyfraction_;
  double neutralhadronenergyfraction_;
  double neutralemenergyfraction_;
  double chargedhadronenergyfraction_;
  ::google::protobuf::uint32 chargedmultiplicity_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_EventCollection_2eproto();
  friend void protobuf_AssignDesc_EventCollection_2eproto();
  friend void protobuf_ShutdownFile_EventCollection_2eproto();
  
  void InitAsDefaultInstance();
  static Jet* default_instance_;
};
// -------------------------------------------------------------------

class Electron : public ::google::protobuf::Message {
 public:
  Electron();
  virtual ~Electron();
  
  Electron(const Electron& from);
  
  inline Electron& operator=(const Electron& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Electron& default_instance();
  
  void Swap(Electron* other);
  
  // implements Message ----------------------------------------------
  
  Electron* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Electron& from);
  void MergeFrom(const Electron& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Electron_ElectronAlgorithm ElectronAlgorithm;
  static const ElectronAlgorithm Calo = Electron_ElectronAlgorithm_Calo;
  static const ElectronAlgorithm ParticleFlow = Electron_ElectronAlgorithm_ParticleFlow;
  static inline bool ElectronAlgorithm_IsValid(int value) {
    return Electron_ElectronAlgorithm_IsValid(value);
  }
  static const ElectronAlgorithm ElectronAlgorithm_MIN =
    Electron_ElectronAlgorithm_ElectronAlgorithm_MIN;
  static const ElectronAlgorithm ElectronAlgorithm_MAX =
    Electron_ElectronAlgorithm_ElectronAlgorithm_MAX;
  static const int ElectronAlgorithm_ARRAYSIZE =
    Electron_ElectronAlgorithm_ElectronAlgorithm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ElectronAlgorithm_descriptor() {
    return Electron_ElectronAlgorithm_descriptor();
  }
  static inline const ::std::string& ElectronAlgorithm_Name(ElectronAlgorithm value) {
    return Electron_ElectronAlgorithm_Name(value);
  }
  static inline bool ElectronAlgorithm_Parse(const ::std::string& name,
      ElectronAlgorithm* value) {
    return Electron_ElectronAlgorithm_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .HEP.Particle basic = 1;
  inline bool has_basic() const;
  inline void clear_basic();
  static const int kBasicFieldNumber = 1;
  inline const ::HEP::Particle& basic() const;
  inline ::HEP::Particle* mutable_basic();
  inline ::HEP::Particle* release_basic();
  
  // optional .HEP.Electron.ElectronAlgorithm type = 2 [default = ParticleFlow];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::HEP::Electron_ElectronAlgorithm type() const;
  inline void set_type(::HEP::Electron_ElectronAlgorithm value);
  
  // required double superCluser_Eta = 3;
  inline bool has_supercluser_eta() const;
  inline void clear_supercluser_eta();
  static const int kSuperCluserEtaFieldNumber = 3;
  inline double supercluser_eta() const;
  inline void set_supercluser_eta(double value);
  
  // optional double ecal_Isolation = 4;
  inline bool has_ecal_isolation() const;
  inline void clear_ecal_isolation();
  static const int kEcalIsolationFieldNumber = 4;
  inline double ecal_isolation() const;
  inline void set_ecal_isolation(double value);
  
  // optional double hcal_Isolation = 5;
  inline bool has_hcal_isolation() const;
  inline void clear_hcal_isolation();
  static const int kHcalIsolationFieldNumber = 5;
  inline double hcal_isolation() const;
  inline void set_hcal_isolation(double value);
  
  // optional double tracker_Isolation = 6;
  inline bool has_tracker_isolation() const;
  inline void clear_tracker_isolation();
  static const int kTrackerIsolationFieldNumber = 6;
  inline double tracker_isolation() const;
  inline void set_tracker_isolation(double value);
  
  // optional double innerLayerMissingHits = 7;
  inline bool has_innerlayermissinghits() const;
  inline void clear_innerlayermissinghits();
  static const int kInnerLayerMissingHitsFieldNumber = 7;
  inline double innerlayermissinghits() const;
  inline void set_innerlayermissinghits(double value);
  
  // optional double sigma_IEtaIEta = 8;
  inline bool has_sigma_ietaieta() const;
  inline void clear_sigma_ietaieta();
  static const int kSigmaIEtaIEtaFieldNumber = 8;
  inline double sigma_ietaieta() const;
  inline void set_sigma_ietaieta(double value);
  
  // optional double dPhi_In = 9;
  inline bool has_dphi_in() const;
  inline void clear_dphi_in();
  static const int kDPhiInFieldNumber = 9;
  inline double dphi_in() const;
  inline void set_dphi_in(double value);
  
  // optional double dEta_In = 10;
  inline bool has_deta_in() const;
  inline void clear_deta_in();
  static const int kDEtaInFieldNumber = 10;
  inline double deta_in() const;
  inline void set_deta_in(double value);
  
  // optional double hadOverEm = 11;
  inline bool has_hadoverem() const;
  inline void clear_hadoverem();
  static const int kHadOverEmFieldNumber = 11;
  inline double hadoverem() const;
  inline void set_hadoverem(double value);
  
  // optional uint32 CiCElectronIDCompressed = 12;
  inline bool has_cicelectronidcompressed() const;
  inline void clear_cicelectronidcompressed();
  static const int kCiCElectronIDCompressedFieldNumber = 12;
  inline ::google::protobuf::uint32 cicelectronidcompressed() const;
  inline void set_cicelectronidcompressed(::google::protobuf::uint32 value);
  
  // optional double sharedFractionInnerHits = 13;
  inline bool has_sharedfractioninnerhits() const;
  inline void clear_sharedfractioninnerhits();
  static const int kSharedFractionInnerHitsFieldNumber = 13;
  inline double sharedfractioninnerhits() const;
  inline void set_sharedfractioninnerhits(double value);
  
  // optional double zDistanceToPrimaryVertex = 14;
  inline bool has_zdistancetoprimaryvertex() const;
  inline void clear_zdistancetoprimaryvertex();
  static const int kZDistanceToPrimaryVertexFieldNumber = 14;
  inline double zdistancetoprimaryvertex() const;
  inline void set_zdistancetoprimaryvertex(double value);
  
  // optional double dCotThetaToNextTrack = 15;
  inline bool has_dcotthetatonexttrack() const;
  inline void clear_dcotthetatonexttrack();
  static const int kDCotThetaToNextTrackFieldNumber = 15;
  inline double dcotthetatonexttrack() const;
  inline void set_dcotthetatonexttrack(double value);
  
  // optional double distToNextTrack = 16;
  inline bool has_disttonexttrack() const;
  inline void clear_disttonexttrack();
  static const int kDistToNextTrackFieldNumber = 16;
  inline double disttonexttrack() const;
  inline void set_disttonexttrack(double value);
  
  // optional double PFGamma_Isolation = 17;
  inline bool has_pfgamma_isolation() const;
  inline void clear_pfgamma_isolation();
  static const int kPFGammaIsolationFieldNumber = 17;
  inline double pfgamma_isolation() const;
  inline void set_pfgamma_isolation(double value);
  
  // optional double PFChargedHadron_Isolation = 18;
  inline bool has_pfchargedhadron_isolation() const;
  inline void clear_pfchargedhadron_isolation();
  static const int kPFChargedHadronIsolationFieldNumber = 18;
  inline double pfchargedhadron_isolation() const;
  inline void set_pfchargedhadron_isolation(double value);
  
  // optional double PFNeutralHadron_Isolation = 19;
  inline bool has_pfneutralhadron_isolation() const;
  inline void clear_pfneutralhadron_isolation();
  static const int kPFNeutralHadronIsolationFieldNumber = 19;
  inline double pfneutralhadron_isolation() const;
  inline void set_pfneutralhadron_isolation(double value);
  
  // @@protoc_insertion_point(class_scope:HEP.Electron)
 private:
  inline void set_has_basic();
  inline void clear_has_basic();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_supercluser_eta();
  inline void clear_has_supercluser_eta();
  inline void set_has_ecal_isolation();
  inline void clear_has_ecal_isolation();
  inline void set_has_hcal_isolation();
  inline void clear_has_hcal_isolation();
  inline void set_has_tracker_isolation();
  inline void clear_has_tracker_isolation();
  inline void set_has_innerlayermissinghits();
  inline void clear_has_innerlayermissinghits();
  inline void set_has_sigma_ietaieta();
  inline void clear_has_sigma_ietaieta();
  inline void set_has_dphi_in();
  inline void clear_has_dphi_in();
  inline void set_has_deta_in();
  inline void clear_has_deta_in();
  inline void set_has_hadoverem();
  inline void clear_has_hadoverem();
  inline void set_has_cicelectronidcompressed();
  inline void clear_has_cicelectronidcompressed();
  inline void set_has_sharedfractioninnerhits();
  inline void clear_has_sharedfractioninnerhits();
  inline void set_has_zdistancetoprimaryvertex();
  inline void clear_has_zdistancetoprimaryvertex();
  inline void set_has_dcotthetatonexttrack();
  inline void clear_has_dcotthetatonexttrack();
  inline void set_has_disttonexttrack();
  inline void clear_has_disttonexttrack();
  inline void set_has_pfgamma_isolation();
  inline void clear_has_pfgamma_isolation();
  inline void set_has_pfchargedhadron_isolation();
  inline void clear_has_pfchargedhadron_isolation();
  inline void set_has_pfneutralhadron_isolation();
  inline void clear_has_pfneutralhadron_isolation();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::HEP::Particle* basic_;
  double supercluser_eta_;
  double ecal_isolation_;
  double hcal_isolation_;
  double tracker_isolation_;
  int type_;
  ::google::protobuf::uint32 cicelectronidcompressed_;
  double innerlayermissinghits_;
  double sigma_ietaieta_;
  double dphi_in_;
  double deta_in_;
  double hadoverem_;
  double sharedfractioninnerhits_;
  double zdistancetoprimaryvertex_;
  double dcotthetatonexttrack_;
  double disttonexttrack_;
  double pfgamma_isolation_;
  double pfchargedhadron_isolation_;
  double pfneutralhadron_isolation_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];
  
  friend void  protobuf_AddDesc_EventCollection_2eproto();
  friend void protobuf_AssignDesc_EventCollection_2eproto();
  friend void protobuf_ShutdownFile_EventCollection_2eproto();
  
  void InitAsDefaultInstance();
  static Electron* default_instance_;
};
// -------------------------------------------------------------------

class Muon : public ::google::protobuf::Message {
 public:
  Muon();
  virtual ~Muon();
  
  Muon(const Muon& from);
  
  inline Muon& operator=(const Muon& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Muon& default_instance();
  
  void Swap(Muon* other);
  
  // implements Message ----------------------------------------------
  
  Muon* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Muon& from);
  void MergeFrom(const Muon& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:HEP.Muon)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_EventCollection_2eproto();
  friend void protobuf_AssignDesc_EventCollection_2eproto();
  friend void protobuf_ShutdownFile_EventCollection_2eproto();
  
  void InitAsDefaultInstance();
  static Muon* default_instance_;
};
// -------------------------------------------------------------------

class MET : public ::google::protobuf::Message {
 public:
  MET();
  virtual ~MET();
  
  MET(const MET& from);
  
  inline MET& operator=(const MET& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MET& default_instance();
  
  void Swap(MET* other);
  
  // implements Message ----------------------------------------------
  
  MET* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MET& from);
  void MergeFrom(const MET& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .HEP.Particle basic = 1;
  inline bool has_basic() const;
  inline void clear_basic();
  static const int kBasicFieldNumber = 1;
  inline const ::HEP::Particle& basic() const;
  inline ::HEP::Particle* mutable_basic();
  inline ::HEP::Particle* release_basic();
  
  // @@protoc_insertion_point(class_scope:HEP.MET)
 private:
  inline void set_has_basic();
  inline void clear_has_basic();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::HEP::Particle* basic_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_EventCollection_2eproto();
  friend void protobuf_AssignDesc_EventCollection_2eproto();
  friend void protobuf_ShutdownFile_EventCollection_2eproto();
  
  void InitAsDefaultInstance();
  static MET* default_instance_;
};
// -------------------------------------------------------------------

class Vertex : public ::google::protobuf::Message {
 public:
  Vertex();
  virtual ~Vertex();
  
  Vertex(const Vertex& from);
  
  inline Vertex& operator=(const Vertex& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vertex& default_instance();
  
  void Swap(Vertex* other);
  
  // implements Message ----------------------------------------------
  
  Vertex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vertex& from);
  void MergeFrom(const Vertex& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool is_fake = 1;
  inline bool has_is_fake() const;
  inline void clear_is_fake();
  static const int kIsFakeFieldNumber = 1;
  inline bool is_fake() const;
  inline void set_is_fake(bool value);
  
  // required uint32 degreesOfFreedom = 2;
  inline bool has_degreesoffreedom() const;
  inline void clear_degreesoffreedom();
  static const int kDegreesOfFreedomFieldNumber = 2;
  inline ::google::protobuf::uint32 degreesoffreedom() const;
  inline void set_degreesoffreedom(::google::protobuf::uint32 value);
  
  // required double z_position = 3;
  inline bool has_z_position() const;
  inline void clear_z_position();
  static const int kZPositionFieldNumber = 3;
  inline double z_position() const;
  inline void set_z_position(double value);
  
  // required double rho = 4;
  inline bool has_rho() const;
  inline void clear_rho();
  static const int kRhoFieldNumber = 4;
  inline double rho() const;
  inline void set_rho(double value);
  
  // @@protoc_insertion_point(class_scope:HEP.Vertex)
 private:
  inline void set_has_is_fake();
  inline void clear_has_is_fake();
  inline void set_has_degreesoffreedom();
  inline void clear_has_degreesoffreedom();
  inline void set_has_z_position();
  inline void clear_has_z_position();
  inline void set_has_rho();
  inline void clear_has_rho();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool is_fake_;
  ::google::protobuf::uint32 degreesoffreedom_;
  double z_position_;
  double rho_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_EventCollection_2eproto();
  friend void protobuf_AssignDesc_EventCollection_2eproto();
  friend void protobuf_ShutdownFile_EventCollection_2eproto();
  
  void InitAsDefaultInstance();
  static Vertex* default_instance_;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message {
 public:
  Event();
  virtual ~Event();
  
  Event(const Event& from);
  
  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();
  
  void Swap(Event* other);
  
  // implements Message ----------------------------------------------
  
  Event* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 run = 1;
  inline bool has_run() const;
  inline void clear_run();
  static const int kRunFieldNumber = 1;
  inline ::google::protobuf::uint32 run() const;
  inline void set_run(::google::protobuf::uint32 value);
  
  // required uint32 lumi = 2;
  inline bool has_lumi() const;
  inline void clear_lumi();
  static const int kLumiFieldNumber = 2;
  inline ::google::protobuf::uint32 lumi() const;
  inline void set_lumi(::google::protobuf::uint32 value);
  
  // optional uint32 number = 3;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 3;
  inline ::google::protobuf::uint32 number() const;
  inline void set_number(::google::protobuf::uint32 value);
  
  // repeated .HEP.Jet jets = 4;
  inline int jets_size() const;
  inline void clear_jets();
  static const int kJetsFieldNumber = 4;
  inline const ::HEP::Jet& jets(int index) const;
  inline ::HEP::Jet* mutable_jets(int index);
  inline ::HEP::Jet* add_jets();
  inline const ::google::protobuf::RepeatedPtrField< ::HEP::Jet >&
      jets() const;
  inline ::google::protobuf::RepeatedPtrField< ::HEP::Jet >*
      mutable_jets();
  
  // repeated .HEP.Electron electrons = 5;
  inline int electrons_size() const;
  inline void clear_electrons();
  static const int kElectronsFieldNumber = 5;
  inline const ::HEP::Electron& electrons(int index) const;
  inline ::HEP::Electron* mutable_electrons(int index);
  inline ::HEP::Electron* add_electrons();
  inline const ::google::protobuf::RepeatedPtrField< ::HEP::Electron >&
      electrons() const;
  inline ::google::protobuf::RepeatedPtrField< ::HEP::Electron >*
      mutable_electrons();
  
  // required .HEP.MET met = 6;
  inline bool has_met() const;
  inline void clear_met();
  static const int kMetFieldNumber = 6;
  inline const ::HEP::MET& met() const;
  inline ::HEP::MET* mutable_met();
  inline ::HEP::MET* release_met();
  
  // repeated .HEP.Vertex vertices = 7;
  inline int vertices_size() const;
  inline void clear_vertices();
  static const int kVerticesFieldNumber = 7;
  inline const ::HEP::Vertex& vertices(int index) const;
  inline ::HEP::Vertex* mutable_vertices(int index);
  inline ::HEP::Vertex* add_vertices();
  inline const ::google::protobuf::RepeatedPtrField< ::HEP::Vertex >&
      vertices() const;
  inline ::google::protobuf::RepeatedPtrField< ::HEP::Vertex >*
      mutable_vertices();
  
  // @@protoc_insertion_point(class_scope:HEP.Event)
 private:
  inline void set_has_run();
  inline void clear_has_run();
  inline void set_has_lumi();
  inline void clear_has_lumi();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_met();
  inline void clear_has_met();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 run_;
  ::google::protobuf::uint32 lumi_;
  ::google::protobuf::RepeatedPtrField< ::HEP::Jet > jets_;
  ::google::protobuf::RepeatedPtrField< ::HEP::Electron > electrons_;
  ::HEP::MET* met_;
  ::google::protobuf::RepeatedPtrField< ::HEP::Vertex > vertices_;
  ::google::protobuf::uint32 number_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_EventCollection_2eproto();
  friend void protobuf_AssignDesc_EventCollection_2eproto();
  friend void protobuf_ShutdownFile_EventCollection_2eproto();
  
  void InitAsDefaultInstance();
  static Event* default_instance_;
};
// -------------------------------------------------------------------

class EventCollection : public ::google::protobuf::Message {
 public:
  EventCollection();
  virtual ~EventCollection();
  
  EventCollection(const EventCollection& from);
  
  inline EventCollection& operator=(const EventCollection& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EventCollection& default_instance();
  
  void Swap(EventCollection* other);
  
  // implements Message ----------------------------------------------
  
  EventCollection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventCollection& from);
  void MergeFrom(const EventCollection& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .HEP.Event event = 1;
  inline int event_size() const;
  inline void clear_event();
  static const int kEventFieldNumber = 1;
  inline const ::HEP::Event& event(int index) const;
  inline ::HEP::Event* mutable_event(int index);
  inline ::HEP::Event* add_event();
  inline const ::google::protobuf::RepeatedPtrField< ::HEP::Event >&
      event() const;
  inline ::google::protobuf::RepeatedPtrField< ::HEP::Event >*
      mutable_event();
  
  // @@protoc_insertion_point(class_scope:HEP.EventCollection)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::HEP::Event > event_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_EventCollection_2eproto();
  friend void protobuf_AssignDesc_EventCollection_2eproto();
  friend void protobuf_ShutdownFile_EventCollection_2eproto();
  
  void InitAsDefaultInstance();
  static EventCollection* default_instance_;
};
// ===================================================================


// ===================================================================

// FourVector

// required double energy = 1;
inline bool FourVector::has_energy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FourVector::set_has_energy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FourVector::clear_has_energy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FourVector::clear_energy() {
  energy_ = 0;
  clear_has_energy();
}
inline double FourVector::energy() const {
  return energy_;
}
inline void FourVector::set_energy(double value) {
  set_has_energy();
  energy_ = value;
}

// required double px = 2;
inline bool FourVector::has_px() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FourVector::set_has_px() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FourVector::clear_has_px() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FourVector::clear_px() {
  px_ = 0;
  clear_has_px();
}
inline double FourVector::px() const {
  return px_;
}
inline void FourVector::set_px(double value) {
  set_has_px();
  px_ = value;
}

// required double py = 3;
inline bool FourVector::has_py() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FourVector::set_has_py() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FourVector::clear_has_py() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FourVector::clear_py() {
  py_ = 0;
  clear_has_py();
}
inline double FourVector::py() const {
  return py_;
}
inline void FourVector::set_py(double value) {
  set_has_py();
  py_ = value;
}

// required double pz = 4;
inline bool FourVector::has_pz() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FourVector::set_has_pz() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FourVector::clear_has_pz() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FourVector::clear_pz() {
  pz_ = 0;
  clear_has_pz();
}
inline double FourVector::pz() const {
  return pz_;
}
inline void FourVector::set_pz(double value) {
  set_has_pz();
  pz_ = value;
}

// -------------------------------------------------------------------

// Particle

// required .HEP.FourVector fourVector = 1;
inline bool Particle::has_fourvector() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Particle::set_has_fourvector() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Particle::clear_has_fourvector() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Particle::clear_fourvector() {
  if (fourvector_ != NULL) fourvector_->::HEP::FourVector::Clear();
  clear_has_fourvector();
}
inline const ::HEP::FourVector& Particle::fourvector() const {
  return fourvector_ != NULL ? *fourvector_ : *default_instance_->fourvector_;
}
inline ::HEP::FourVector* Particle::mutable_fourvector() {
  set_has_fourvector();
  if (fourvector_ == NULL) fourvector_ = new ::HEP::FourVector;
  return fourvector_;
}
inline ::HEP::FourVector* Particle::release_fourvector() {
  clear_has_fourvector();
  ::HEP::FourVector* temp = fourvector_;
  fourvector_ = NULL;
  return temp;
}

// required double charge = 2;
inline bool Particle::has_charge() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Particle::set_has_charge() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Particle::clear_has_charge() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Particle::clear_charge() {
  charge_ = 0;
  clear_has_charge();
}
inline double Particle::charge() const {
  return charge_;
}
inline void Particle::set_charge(double value) {
  set_has_charge();
  charge_ = value;
}

// required double mass = 3;
inline bool Particle::has_mass() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Particle::set_has_mass() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Particle::clear_has_mass() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Particle::clear_mass() {
  mass_ = 0;
  clear_has_mass();
}
inline double Particle::mass() const {
  return mass_;
}
inline void Particle::set_mass(double value) {
  set_has_mass();
  mass_ = value;
}

// -------------------------------------------------------------------

// Jet

// required .HEP.Particle basic = 1;
inline bool Jet::has_basic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Jet::set_has_basic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Jet::clear_has_basic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Jet::clear_basic() {
  if (basic_ != NULL) basic_->::HEP::Particle::Clear();
  clear_has_basic();
}
inline const ::HEP::Particle& Jet::basic() const {
  return basic_ != NULL ? *basic_ : *default_instance_->basic_;
}
inline ::HEP::Particle* Jet::mutable_basic() {
  set_has_basic();
  if (basic_ == NULL) basic_ = new ::HEP::Particle;
  return basic_;
}
inline ::HEP::Particle* Jet::release_basic() {
  clear_has_basic();
  ::HEP::Particle* temp = basic_;
  basic_ = NULL;
  return temp;
}

// optional .HEP.Jet.JetAlgorithm type = 2 [default = PF2PAT];
inline bool Jet::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Jet::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Jet::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Jet::clear_type() {
  type_ = 2;
  clear_has_type();
}
inline ::HEP::Jet_JetAlgorithm Jet::type() const {
  return static_cast< ::HEP::Jet_JetAlgorithm >(type_);
}
inline void Jet::set_type(::HEP::Jet_JetAlgorithm value) {
  GOOGLE_DCHECK(::HEP::Jet_JetAlgorithm_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional double electromagneticFraction = 3 [default = 0];
inline bool Jet::has_electromagneticfraction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Jet::set_has_electromagneticfraction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Jet::clear_has_electromagneticfraction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Jet::clear_electromagneticfraction() {
  electromagneticfraction_ = 0;
  clear_has_electromagneticfraction();
}
inline double Jet::electromagneticfraction() const {
  return electromagneticfraction_;
}
inline void Jet::set_electromagneticfraction(double value) {
  set_has_electromagneticfraction();
  electromagneticfraction_ = value;
}

// optional double numberOfRecHitsContaining90PercentOfTheJetEnergy = 4 [default = 0];
inline bool Jet::has_numberofrechitscontaining90percentofthejetenergy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Jet::set_has_numberofrechitscontaining90percentofthejetenergy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Jet::clear_has_numberofrechitscontaining90percentofthejetenergy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Jet::clear_numberofrechitscontaining90percentofthejetenergy() {
  numberofrechitscontaining90percentofthejetenergy_ = 0;
  clear_has_numberofrechitscontaining90percentofthejetenergy();
}
inline double Jet::numberofrechitscontaining90percentofthejetenergy() const {
  return numberofrechitscontaining90percentofthejetenergy_;
}
inline void Jet::set_numberofrechitscontaining90percentofthejetenergy(double value) {
  set_has_numberofrechitscontaining90percentofthejetenergy();
  numberofrechitscontaining90percentofthejetenergy_ = value;
}

// optional double fractionOfEnergyIntheHottestHPDReadout = 5 [default = 0];
inline bool Jet::has_fractionofenergyinthehottesthpdreadout() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Jet::set_has_fractionofenergyinthehottesthpdreadout() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Jet::clear_has_fractionofenergyinthehottesthpdreadout() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Jet::clear_fractionofenergyinthehottesthpdreadout() {
  fractionofenergyinthehottesthpdreadout_ = 0;
  clear_has_fractionofenergyinthehottesthpdreadout();
}
inline double Jet::fractionofenergyinthehottesthpdreadout() const {
  return fractionofenergyinthehottesthpdreadout_;
}
inline void Jet::set_fractionofenergyinthehottesthpdreadout(double value) {
  set_has_fractionofenergyinthehottesthpdreadout();
  fractionofenergyinthehottesthpdreadout_ = value;
}

// optional uint32 numberOfDaughters = 6 [default = 0];
inline bool Jet::has_numberofdaughters() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Jet::set_has_numberofdaughters() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Jet::clear_has_numberofdaughters() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Jet::clear_numberofdaughters() {
  numberofdaughters_ = 0u;
  clear_has_numberofdaughters();
}
inline ::google::protobuf::uint32 Jet::numberofdaughters() const {
  return numberofdaughters_;
}
inline void Jet::set_numberofdaughters(::google::protobuf::uint32 value) {
  set_has_numberofdaughters();
  numberofdaughters_ = value;
}

// optional double chargedEmEnergyFraction = 7 [default = 1];
inline bool Jet::has_chargedemenergyfraction() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Jet::set_has_chargedemenergyfraction() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Jet::clear_has_chargedemenergyfraction() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Jet::clear_chargedemenergyfraction() {
  chargedemenergyfraction_ = 1;
  clear_has_chargedemenergyfraction();
}
inline double Jet::chargedemenergyfraction() const {
  return chargedemenergyfraction_;
}
inline void Jet::set_chargedemenergyfraction(double value) {
  set_has_chargedemenergyfraction();
  chargedemenergyfraction_ = value;
}

// optional double neutralHadronEnergyFraction = 8 [default = 1];
inline bool Jet::has_neutralhadronenergyfraction() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Jet::set_has_neutralhadronenergyfraction() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Jet::clear_has_neutralhadronenergyfraction() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Jet::clear_neutralhadronenergyfraction() {
  neutralhadronenergyfraction_ = 1;
  clear_has_neutralhadronenergyfraction();
}
inline double Jet::neutralhadronenergyfraction() const {
  return neutralhadronenergyfraction_;
}
inline void Jet::set_neutralhadronenergyfraction(double value) {
  set_has_neutralhadronenergyfraction();
  neutralhadronenergyfraction_ = value;
}

// optional double neutralEmEnergyFraction = 9 [default = 1];
inline bool Jet::has_neutralemenergyfraction() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Jet::set_has_neutralemenergyfraction() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Jet::clear_has_neutralemenergyfraction() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Jet::clear_neutralemenergyfraction() {
  neutralemenergyfraction_ = 1;
  clear_has_neutralemenergyfraction();
}
inline double Jet::neutralemenergyfraction() const {
  return neutralemenergyfraction_;
}
inline void Jet::set_neutralemenergyfraction(double value) {
  set_has_neutralemenergyfraction();
  neutralemenergyfraction_ = value;
}

// optional double chargedHadronEnergyFraction = 10 [default = 1];
inline bool Jet::has_chargedhadronenergyfraction() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Jet::set_has_chargedhadronenergyfraction() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Jet::clear_has_chargedhadronenergyfraction() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Jet::clear_chargedhadronenergyfraction() {
  chargedhadronenergyfraction_ = 1;
  clear_has_chargedhadronenergyfraction();
}
inline double Jet::chargedhadronenergyfraction() const {
  return chargedhadronenergyfraction_;
}
inline void Jet::set_chargedhadronenergyfraction(double value) {
  set_has_chargedhadronenergyfraction();
  chargedhadronenergyfraction_ = value;
}

// optional uint32 chargedMultiplicity = 11 [default = 0];
inline bool Jet::has_chargedmultiplicity() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Jet::set_has_chargedmultiplicity() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Jet::clear_has_chargedmultiplicity() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Jet::clear_chargedmultiplicity() {
  chargedmultiplicity_ = 0u;
  clear_has_chargedmultiplicity();
}
inline ::google::protobuf::uint32 Jet::chargedmultiplicity() const {
  return chargedmultiplicity_;
}
inline void Jet::set_chargedmultiplicity(::google::protobuf::uint32 value) {
  set_has_chargedmultiplicity();
  chargedmultiplicity_ = value;
}

// -------------------------------------------------------------------

// Electron

// required .HEP.Particle basic = 1;
inline bool Electron::has_basic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Electron::set_has_basic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Electron::clear_has_basic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Electron::clear_basic() {
  if (basic_ != NULL) basic_->::HEP::Particle::Clear();
  clear_has_basic();
}
inline const ::HEP::Particle& Electron::basic() const {
  return basic_ != NULL ? *basic_ : *default_instance_->basic_;
}
inline ::HEP::Particle* Electron::mutable_basic() {
  set_has_basic();
  if (basic_ == NULL) basic_ = new ::HEP::Particle;
  return basic_;
}
inline ::HEP::Particle* Electron::release_basic() {
  clear_has_basic();
  ::HEP::Particle* temp = basic_;
  basic_ = NULL;
  return temp;
}

// optional .HEP.Electron.ElectronAlgorithm type = 2 [default = ParticleFlow];
inline bool Electron::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Electron::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Electron::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Electron::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::HEP::Electron_ElectronAlgorithm Electron::type() const {
  return static_cast< ::HEP::Electron_ElectronAlgorithm >(type_);
}
inline void Electron::set_type(::HEP::Electron_ElectronAlgorithm value) {
  GOOGLE_DCHECK(::HEP::Electron_ElectronAlgorithm_IsValid(value));
  set_has_type();
  type_ = value;
}

// required double superCluser_Eta = 3;
inline bool Electron::has_supercluser_eta() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Electron::set_has_supercluser_eta() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Electron::clear_has_supercluser_eta() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Electron::clear_supercluser_eta() {
  supercluser_eta_ = 0;
  clear_has_supercluser_eta();
}
inline double Electron::supercluser_eta() const {
  return supercluser_eta_;
}
inline void Electron::set_supercluser_eta(double value) {
  set_has_supercluser_eta();
  supercluser_eta_ = value;
}

// optional double ecal_Isolation = 4;
inline bool Electron::has_ecal_isolation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Electron::set_has_ecal_isolation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Electron::clear_has_ecal_isolation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Electron::clear_ecal_isolation() {
  ecal_isolation_ = 0;
  clear_has_ecal_isolation();
}
inline double Electron::ecal_isolation() const {
  return ecal_isolation_;
}
inline void Electron::set_ecal_isolation(double value) {
  set_has_ecal_isolation();
  ecal_isolation_ = value;
}

// optional double hcal_Isolation = 5;
inline bool Electron::has_hcal_isolation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Electron::set_has_hcal_isolation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Electron::clear_has_hcal_isolation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Electron::clear_hcal_isolation() {
  hcal_isolation_ = 0;
  clear_has_hcal_isolation();
}
inline double Electron::hcal_isolation() const {
  return hcal_isolation_;
}
inline void Electron::set_hcal_isolation(double value) {
  set_has_hcal_isolation();
  hcal_isolation_ = value;
}

// optional double tracker_Isolation = 6;
inline bool Electron::has_tracker_isolation() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Electron::set_has_tracker_isolation() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Electron::clear_has_tracker_isolation() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Electron::clear_tracker_isolation() {
  tracker_isolation_ = 0;
  clear_has_tracker_isolation();
}
inline double Electron::tracker_isolation() const {
  return tracker_isolation_;
}
inline void Electron::set_tracker_isolation(double value) {
  set_has_tracker_isolation();
  tracker_isolation_ = value;
}

// optional double innerLayerMissingHits = 7;
inline bool Electron::has_innerlayermissinghits() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Electron::set_has_innerlayermissinghits() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Electron::clear_has_innerlayermissinghits() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Electron::clear_innerlayermissinghits() {
  innerlayermissinghits_ = 0;
  clear_has_innerlayermissinghits();
}
inline double Electron::innerlayermissinghits() const {
  return innerlayermissinghits_;
}
inline void Electron::set_innerlayermissinghits(double value) {
  set_has_innerlayermissinghits();
  innerlayermissinghits_ = value;
}

// optional double sigma_IEtaIEta = 8;
inline bool Electron::has_sigma_ietaieta() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Electron::set_has_sigma_ietaieta() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Electron::clear_has_sigma_ietaieta() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Electron::clear_sigma_ietaieta() {
  sigma_ietaieta_ = 0;
  clear_has_sigma_ietaieta();
}
inline double Electron::sigma_ietaieta() const {
  return sigma_ietaieta_;
}
inline void Electron::set_sigma_ietaieta(double value) {
  set_has_sigma_ietaieta();
  sigma_ietaieta_ = value;
}

// optional double dPhi_In = 9;
inline bool Electron::has_dphi_in() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Electron::set_has_dphi_in() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Electron::clear_has_dphi_in() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Electron::clear_dphi_in() {
  dphi_in_ = 0;
  clear_has_dphi_in();
}
inline double Electron::dphi_in() const {
  return dphi_in_;
}
inline void Electron::set_dphi_in(double value) {
  set_has_dphi_in();
  dphi_in_ = value;
}

// optional double dEta_In = 10;
inline bool Electron::has_deta_in() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Electron::set_has_deta_in() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Electron::clear_has_deta_in() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Electron::clear_deta_in() {
  deta_in_ = 0;
  clear_has_deta_in();
}
inline double Electron::deta_in() const {
  return deta_in_;
}
inline void Electron::set_deta_in(double value) {
  set_has_deta_in();
  deta_in_ = value;
}

// optional double hadOverEm = 11;
inline bool Electron::has_hadoverem() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Electron::set_has_hadoverem() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Electron::clear_has_hadoverem() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Electron::clear_hadoverem() {
  hadoverem_ = 0;
  clear_has_hadoverem();
}
inline double Electron::hadoverem() const {
  return hadoverem_;
}
inline void Electron::set_hadoverem(double value) {
  set_has_hadoverem();
  hadoverem_ = value;
}

// optional uint32 CiCElectronIDCompressed = 12;
inline bool Electron::has_cicelectronidcompressed() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Electron::set_has_cicelectronidcompressed() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Electron::clear_has_cicelectronidcompressed() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Electron::clear_cicelectronidcompressed() {
  cicelectronidcompressed_ = 0u;
  clear_has_cicelectronidcompressed();
}
inline ::google::protobuf::uint32 Electron::cicelectronidcompressed() const {
  return cicelectronidcompressed_;
}
inline void Electron::set_cicelectronidcompressed(::google::protobuf::uint32 value) {
  set_has_cicelectronidcompressed();
  cicelectronidcompressed_ = value;
}

// optional double sharedFractionInnerHits = 13;
inline bool Electron::has_sharedfractioninnerhits() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Electron::set_has_sharedfractioninnerhits() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Electron::clear_has_sharedfractioninnerhits() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Electron::clear_sharedfractioninnerhits() {
  sharedfractioninnerhits_ = 0;
  clear_has_sharedfractioninnerhits();
}
inline double Electron::sharedfractioninnerhits() const {
  return sharedfractioninnerhits_;
}
inline void Electron::set_sharedfractioninnerhits(double value) {
  set_has_sharedfractioninnerhits();
  sharedfractioninnerhits_ = value;
}

// optional double zDistanceToPrimaryVertex = 14;
inline bool Electron::has_zdistancetoprimaryvertex() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Electron::set_has_zdistancetoprimaryvertex() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Electron::clear_has_zdistancetoprimaryvertex() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Electron::clear_zdistancetoprimaryvertex() {
  zdistancetoprimaryvertex_ = 0;
  clear_has_zdistancetoprimaryvertex();
}
inline double Electron::zdistancetoprimaryvertex() const {
  return zdistancetoprimaryvertex_;
}
inline void Electron::set_zdistancetoprimaryvertex(double value) {
  set_has_zdistancetoprimaryvertex();
  zdistancetoprimaryvertex_ = value;
}

// optional double dCotThetaToNextTrack = 15;
inline bool Electron::has_dcotthetatonexttrack() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Electron::set_has_dcotthetatonexttrack() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Electron::clear_has_dcotthetatonexttrack() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Electron::clear_dcotthetatonexttrack() {
  dcotthetatonexttrack_ = 0;
  clear_has_dcotthetatonexttrack();
}
inline double Electron::dcotthetatonexttrack() const {
  return dcotthetatonexttrack_;
}
inline void Electron::set_dcotthetatonexttrack(double value) {
  set_has_dcotthetatonexttrack();
  dcotthetatonexttrack_ = value;
}

// optional double distToNextTrack = 16;
inline bool Electron::has_disttonexttrack() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Electron::set_has_disttonexttrack() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Electron::clear_has_disttonexttrack() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Electron::clear_disttonexttrack() {
  disttonexttrack_ = 0;
  clear_has_disttonexttrack();
}
inline double Electron::disttonexttrack() const {
  return disttonexttrack_;
}
inline void Electron::set_disttonexttrack(double value) {
  set_has_disttonexttrack();
  disttonexttrack_ = value;
}

// optional double PFGamma_Isolation = 17;
inline bool Electron::has_pfgamma_isolation() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Electron::set_has_pfgamma_isolation() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Electron::clear_has_pfgamma_isolation() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Electron::clear_pfgamma_isolation() {
  pfgamma_isolation_ = 0;
  clear_has_pfgamma_isolation();
}
inline double Electron::pfgamma_isolation() const {
  return pfgamma_isolation_;
}
inline void Electron::set_pfgamma_isolation(double value) {
  set_has_pfgamma_isolation();
  pfgamma_isolation_ = value;
}

// optional double PFChargedHadron_Isolation = 18;
inline bool Electron::has_pfchargedhadron_isolation() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Electron::set_has_pfchargedhadron_isolation() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Electron::clear_has_pfchargedhadron_isolation() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Electron::clear_pfchargedhadron_isolation() {
  pfchargedhadron_isolation_ = 0;
  clear_has_pfchargedhadron_isolation();
}
inline double Electron::pfchargedhadron_isolation() const {
  return pfchargedhadron_isolation_;
}
inline void Electron::set_pfchargedhadron_isolation(double value) {
  set_has_pfchargedhadron_isolation();
  pfchargedhadron_isolation_ = value;
}

// optional double PFNeutralHadron_Isolation = 19;
inline bool Electron::has_pfneutralhadron_isolation() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Electron::set_has_pfneutralhadron_isolation() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Electron::clear_has_pfneutralhadron_isolation() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Electron::clear_pfneutralhadron_isolation() {
  pfneutralhadron_isolation_ = 0;
  clear_has_pfneutralhadron_isolation();
}
inline double Electron::pfneutralhadron_isolation() const {
  return pfneutralhadron_isolation_;
}
inline void Electron::set_pfneutralhadron_isolation(double value) {
  set_has_pfneutralhadron_isolation();
  pfneutralhadron_isolation_ = value;
}

// -------------------------------------------------------------------

// Muon

// -------------------------------------------------------------------

// MET

// required .HEP.Particle basic = 1;
inline bool MET::has_basic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MET::set_has_basic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MET::clear_has_basic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MET::clear_basic() {
  if (basic_ != NULL) basic_->::HEP::Particle::Clear();
  clear_has_basic();
}
inline const ::HEP::Particle& MET::basic() const {
  return basic_ != NULL ? *basic_ : *default_instance_->basic_;
}
inline ::HEP::Particle* MET::mutable_basic() {
  set_has_basic();
  if (basic_ == NULL) basic_ = new ::HEP::Particle;
  return basic_;
}
inline ::HEP::Particle* MET::release_basic() {
  clear_has_basic();
  ::HEP::Particle* temp = basic_;
  basic_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Vertex

// required bool is_fake = 1;
inline bool Vertex::has_is_fake() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vertex::set_has_is_fake() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vertex::clear_has_is_fake() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vertex::clear_is_fake() {
  is_fake_ = false;
  clear_has_is_fake();
}
inline bool Vertex::is_fake() const {
  return is_fake_;
}
inline void Vertex::set_is_fake(bool value) {
  set_has_is_fake();
  is_fake_ = value;
}

// required uint32 degreesOfFreedom = 2;
inline bool Vertex::has_degreesoffreedom() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vertex::set_has_degreesoffreedom() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vertex::clear_has_degreesoffreedom() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vertex::clear_degreesoffreedom() {
  degreesoffreedom_ = 0u;
  clear_has_degreesoffreedom();
}
inline ::google::protobuf::uint32 Vertex::degreesoffreedom() const {
  return degreesoffreedom_;
}
inline void Vertex::set_degreesoffreedom(::google::protobuf::uint32 value) {
  set_has_degreesoffreedom();
  degreesoffreedom_ = value;
}

// required double z_position = 3;
inline bool Vertex::has_z_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vertex::set_has_z_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vertex::clear_has_z_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vertex::clear_z_position() {
  z_position_ = 0;
  clear_has_z_position();
}
inline double Vertex::z_position() const {
  return z_position_;
}
inline void Vertex::set_z_position(double value) {
  set_has_z_position();
  z_position_ = value;
}

// required double rho = 4;
inline bool Vertex::has_rho() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Vertex::set_has_rho() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Vertex::clear_has_rho() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Vertex::clear_rho() {
  rho_ = 0;
  clear_has_rho();
}
inline double Vertex::rho() const {
  return rho_;
}
inline void Vertex::set_rho(double value) {
  set_has_rho();
  rho_ = value;
}

// -------------------------------------------------------------------

// Event

// required uint32 run = 1;
inline bool Event::has_run() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event::set_has_run() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event::clear_has_run() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event::clear_run() {
  run_ = 0u;
  clear_has_run();
}
inline ::google::protobuf::uint32 Event::run() const {
  return run_;
}
inline void Event::set_run(::google::protobuf::uint32 value) {
  set_has_run();
  run_ = value;
}

// required uint32 lumi = 2;
inline bool Event::has_lumi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event::set_has_lumi() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event::clear_has_lumi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Event::clear_lumi() {
  lumi_ = 0u;
  clear_has_lumi();
}
inline ::google::protobuf::uint32 Event::lumi() const {
  return lumi_;
}
inline void Event::set_lumi(::google::protobuf::uint32 value) {
  set_has_lumi();
  lumi_ = value;
}

// optional uint32 number = 3;
inline bool Event::has_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Event::set_has_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Event::clear_has_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Event::clear_number() {
  number_ = 0u;
  clear_has_number();
}
inline ::google::protobuf::uint32 Event::number() const {
  return number_;
}
inline void Event::set_number(::google::protobuf::uint32 value) {
  set_has_number();
  number_ = value;
}

// repeated .HEP.Jet jets = 4;
inline int Event::jets_size() const {
  return jets_.size();
}
inline void Event::clear_jets() {
  jets_.Clear();
}
inline const ::HEP::Jet& Event::jets(int index) const {
  return jets_.Get(index);
}
inline ::HEP::Jet* Event::mutable_jets(int index) {
  return jets_.Mutable(index);
}
inline ::HEP::Jet* Event::add_jets() {
  return jets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HEP::Jet >&
Event::jets() const {
  return jets_;
}
inline ::google::protobuf::RepeatedPtrField< ::HEP::Jet >*
Event::mutable_jets() {
  return &jets_;
}

// repeated .HEP.Electron electrons = 5;
inline int Event::electrons_size() const {
  return electrons_.size();
}
inline void Event::clear_electrons() {
  electrons_.Clear();
}
inline const ::HEP::Electron& Event::electrons(int index) const {
  return electrons_.Get(index);
}
inline ::HEP::Electron* Event::mutable_electrons(int index) {
  return electrons_.Mutable(index);
}
inline ::HEP::Electron* Event::add_electrons() {
  return electrons_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HEP::Electron >&
Event::electrons() const {
  return electrons_;
}
inline ::google::protobuf::RepeatedPtrField< ::HEP::Electron >*
Event::mutable_electrons() {
  return &electrons_;
}

// required .HEP.MET met = 6;
inline bool Event::has_met() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Event::set_has_met() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Event::clear_has_met() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Event::clear_met() {
  if (met_ != NULL) met_->::HEP::MET::Clear();
  clear_has_met();
}
inline const ::HEP::MET& Event::met() const {
  return met_ != NULL ? *met_ : *default_instance_->met_;
}
inline ::HEP::MET* Event::mutable_met() {
  set_has_met();
  if (met_ == NULL) met_ = new ::HEP::MET;
  return met_;
}
inline ::HEP::MET* Event::release_met() {
  clear_has_met();
  ::HEP::MET* temp = met_;
  met_ = NULL;
  return temp;
}

// repeated .HEP.Vertex vertices = 7;
inline int Event::vertices_size() const {
  return vertices_.size();
}
inline void Event::clear_vertices() {
  vertices_.Clear();
}
inline const ::HEP::Vertex& Event::vertices(int index) const {
  return vertices_.Get(index);
}
inline ::HEP::Vertex* Event::mutable_vertices(int index) {
  return vertices_.Mutable(index);
}
inline ::HEP::Vertex* Event::add_vertices() {
  return vertices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HEP::Vertex >&
Event::vertices() const {
  return vertices_;
}
inline ::google::protobuf::RepeatedPtrField< ::HEP::Vertex >*
Event::mutable_vertices() {
  return &vertices_;
}

// -------------------------------------------------------------------

// EventCollection

// repeated .HEP.Event event = 1;
inline int EventCollection::event_size() const {
  return event_.size();
}
inline void EventCollection::clear_event() {
  event_.Clear();
}
inline const ::HEP::Event& EventCollection::event(int index) const {
  return event_.Get(index);
}
inline ::HEP::Event* EventCollection::mutable_event(int index) {
  return event_.Mutable(index);
}
inline ::HEP::Event* EventCollection::add_event() {
  return event_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HEP::Event >&
EventCollection::event() const {
  return event_;
}
inline ::google::protobuf::RepeatedPtrField< ::HEP::Event >*
EventCollection::mutable_event() {
  return &event_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace HEP

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HEP::Jet_JetAlgorithm>() {
  return ::HEP::Jet_JetAlgorithm_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HEP::Electron_ElectronAlgorithm>() {
  return ::HEP::Electron_ElectronAlgorithm_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_EventCollection_2eproto__INCLUDED
